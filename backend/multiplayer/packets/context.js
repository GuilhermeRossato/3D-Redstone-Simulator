import fs from 'fs';
import { loadBlockMetadata } from "../../lib/blocks/BlockMetadataStorage.js";
import { blockNamingList, loadBlockNamingData } from "../../lib/blocks/BlockNamingStorage.js";
import { ServerChunk } from "../../lib/ServerChunk.js";
import { ServerRegion } from "../../lib/ServerRegion.js";
import { getChunkOffsets } from "../../scripts/chunkDistance.js";
import { getProjectFolderPath } from "../../utils/getProjectFolderPath.js";

let updatedBlockDefinitions = false;

async function getBlockDefinitions() {
  if (blockNamingList.length === 0) {
    await loadBlockNamingData();
  }
  const blocks = {};
  for (const obj of blockNamingList) {
    if (!obj) continue;
    if (!obj.data || !obj.data.loaded || Date.now() - obj.data.loaded > 120_000) {
      obj.data = await loadBlockMetadata(obj.id, false);
    }
    blocks[obj.id] = { data: obj.data, key: obj.key, id: obj.id };
    const keys = obj.data?Object.keys(obj.data).sort():[];
    if (blocks[obj.id] && keys.length === 0 || ['id,data','data','loaded'].includes(keys.join(','))) {
      delete blocks[obj.id].data;
    }
  }

  
  if (!blocks || Object.keys(blocks).length === 0) {
    console.warn("No block definitions found or loaded.");
  } else if (!updatedBlockDefinitions) {
    try {
      const blockDefinitionPath = getProjectFolderPath("frontend", "src", "constants", "BlockDefinitions.js");

      let shouldUpdate = false;
      try {
        const stat = await fs.promises.stat(blockDefinitionPath);
        if (!shouldUpdate && Date.now() - stat.mtimeMs > 180_000) {
          shouldUpdate = true;
        }
      } catch (err) {
        shouldUpdate = true;
      }
      if (shouldUpdate) {
        updatedBlockDefinitions = true;

        console.log("Updating block definitions file:", blockDefinitionPath);
        const disclaimer = "/* Do not edit this file: It has been generated by combining block ids, names and metadata on the server. */"
        await fs.promises.writeFile(
          blockDefinitionPath,
          `${disclaimer}\n\nexport const BlockDefinitions = ${JSON.stringify(blocks, null, 2)};\n`,
          'utf-8'
        );
      }
    } catch (err) {
      console.log("Error writing block definitions file:", err.message);
    }
  }

  return blocks;
}

export default async function context(payload, ctx) {
  if (!ctx.player) {
    throw new Error("Missing player context: Send setup first.");
  }
  if (!isNaN(payload.offset)) {
    ctx.offset = payload.offset;
  }
  const offsets = await getChunkOffsets(9, 3);
  if (!offsets.length) {
    throw new Error("Invalid chunk position list");
  }
  const regionsPos = offsets.map((a) => a.split(',').slice(0, 3).map((a, i) => parseInt(a) * 64 + ctx.player.pose[i]));
  const chunksPos = offsets.map((a) => a.split(',').slice(0, 3).map((a, i) => parseInt(a) * 16 + ctx.player.pose[i]));
  const regions = regionsPos.map((pos) => ServerRegion.fromAbsolute(pos)).filter((o, i) => i <= 1 || o.existsSync());
  const chunks = chunksPos.map((pos) => ServerChunk.fromAbsolute(pos)).filter((o, i) => i <= 1 || o.existsSync());

  await chunks[0].load();
  await regions[0].load();

  const blocks = await getBlockDefinitions();

  return {
    player: ctx.player,
    regions: regions.map((r, i) => ({
      id: r.id,
      rx: r.rx,
      ry: r.ry,
      rz: r.rz,
      entities: i === 0 ? r.state.entities : undefined,
    })),
    chunks: chunks.map((c, i) => ({
      id: c.id,
      cx: c.cx,
      cy: c.cy,
      cz: c.cz,
      blocks: i === 0 ? c.state.blocks : undefined,
    })),
    blocks,
  };
}
